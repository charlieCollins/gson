
PROCESS NOTES
————————————

start with json, no deps beyond simple java (cheating a little) 

goal
compile java (just to make sure it works, extra step to get in habit) 
transpile to obj-c
compile objc-c
transpile/compile gson TESTS
run the tests as OBJECTIVE MUTHA FUCKIN C

http://j2objc.org/docs/Design-Overview.html
1. rewriter rewrites stuff that doesn’t have java equivalent, it all started here, was bigger, stuff split out
2. autoboxer
3. iostypeconverter — foundation classes, object, number, string, throwable, class, etc
4. iosmethodconverter - uses a mapping table to “fix” method names, no overloading allowed!
5. initialization normalizer - static vars and static blocks and any init stuff moved into initializers
6. anon class converter - makes anon classes into inner classes
7. inner class converter - makes inner classes top level classes “in sample compilation unit” (runs after anon class step, so once this is done it’s all top level, yup)
8. destructor converter - creates mem momt destructors as needed, tries to deal with finalize, depends on arc or not, etc
9. complex expression extractor - breaks up complex expressions like chained method calls
10. nil check resolver - ads nil_chk wherever an expression is dereferenced

https://groups.google.com/forum/#!topic/j2objc-discuss/iXdtl4KRP1k
notes from tom:
Here are the basic steps:

Run "rm -rf /tmp/build && mkdir /tmp/build"
Run "javac -d /tmp/build BLSSMIBI.java" (or whatever that file is named that created BLSSMIBI.o)
Run "find /tmp/build -name '*.class' | fgrep -v '$' | sed 's/class$/java/' | sed 's/\/tmp\/build\///' > sources.list
Run "sed 's/java$/m/' sources.list > objc-files.list

The first step creates a clean build environment. 
The second step compiles the Java source; javac will also compile any dependent classes that are in the source path ("." by default). If the javac command fails, add a "-sourcepath path" argument to it and retry, adjusting the source path until javac completes without errors. DO NOT add a class path argument unless it's for an already translated library like libjunit.a -- all app dependencies should use Java sources (if you don't have source, then the code can't be translated).
The third step: a) lists the class files javac generated, b) filters out any inner or anonymous classes from that list, c) converts the ".class" suffixes to ".java", d) removes the /tmp/javac from the file names, and e) saves the list to the sources.list file. 
The fourth step creates a list of ".m" files for each Java source, saving it to objc-files.list.

These steps generate the complete closure of all source files needed for the app. Now, translate them all ("j2objc -d /tmp/build flags $(cat sources.list)" will do it in one step), then compile them all ("j2objcc -o executable_name -I/tmp/build $(cat objc-files.list)"). Since sources.list has all the Java dependencies, objc-files.list will have all the dependent code, resolving any link errors from missing object files.

Once these steps work, consider copying them into a script file such as build.sh, so future builds can be run using "bash build.sh".


mvn test
runs 1018 tests as java, all good, proceed

mvn dependency:unpack-dependencies -Dclassifier=sources
this puts all the stuff in target/dependency

find ../src/main -name "*.java" > sources.txt 

find ../src/test -name "*.java" > sources_test.txt 

1. transpile regular source to objc source 0 j2objc

mkdir build_java                  
javac -d ./build_java @sources.txt

2. j2objc that shit with same command to diff output dir

j2objc -d ./build_objc @sources.txt

3. j2objcc that shit into o binaries?



find ../src -name "*.java" > sources_all.txt
javac -d ./build_java @sources_all.txt
javac -classpath ~/.m2/repository/junit/junit/4.12/junit-4.12.jar -d ./build_java @sources_all.txt
j2objc --no-package-directories -classpath ~/.m2/repository/junit/junit/4.12/junit-4.12.jar -d ./build_objc @sources_all.txt
j2objcc -Wno-deprecated -ObjC -o gsonobjc -ljre_emul -ljunit ./build_objc/*.m
./gsonobjc org.junit.runner.JUnitCore ComGoogleGsonCommentsTest

holy shit it worked
JUnit version 4.11
.
Time: 0.004

OK (1 test)

get all the top level "tests" from the interface files...
find ./build_objc/*Test.h -exec grep -hw -m1 "$@interface" {} \; | sed 's/@interface//' | sed 's/ ().*//' | sed 's/ :.*//' > test_names.txt

run them
for i in `cat test_names.txt`; do ./gsonobjc org.junit.runner.JUnitCore $i; done

for i in `cat test_names.txt`; do echo RUNNING: $i; ./gsonobjc org.junit.runner.JUnitCore $i; done
